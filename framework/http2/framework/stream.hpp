//
// Created by Rakesh on 06/01/2025.
//

#pragma once

#include "common.hpp"
#include "request.hpp"
#include "response.hpp"
#include "router.hpp"

#include <array>
#include <atomic>
#include <mutex>

#include <boost/asio/thread_pool.hpp>

namespace spt::http2::framework
{
  /**
   * Specialise this function to perform any additional processing using information in the request and response.
   * Some use cases are to publish a metric related to this request process to a time series database, kick off
   * some async process based on the request/response etc.
   *
   * The thread pool can be used to post asynchronous processing to.  When doing so, keep in mind the request
   * and response may no longer be valid when the process is executed.
   * @tparam Resp The response type
   */
  template <Response Resp>
  void extraProcess( const Request&, Resp&, boost::asio::thread_pool& ) { /* No actions by default */ }

  /**
   * Process a HTTP request from a client.  Delegate to the `Router` to route the request as appropriate.
   * Write the response to the nghttp2 response if the client connection is still active.  ALso invoke
   * any extra processing implemented by the user via any specialised `extraProcess` function.
   * @tparam Resp The response type generated by the endpoint handler.
   */
  template <Response Resp>
  class Stream : public std::enable_shared_from_this<Stream<Resp>>
  {
  public:
    /**
     * Create a new request processing instance.
     * @param req The nghttp2 request object.
     * @param res The nghttp2 response object.
     * @param router The router to route requests to the appropriate endpoint handler.
     * @param payload Optional payload submitted by HTTP client.
     */
    Stream( const nghttp2::asio_http2::server::request& req, const nghttp2::asio_http2::server::response& res,
      const Router<Resp>& router, std::shared_ptr<std::string> payload = nullptr ) :
          request{ req }, req{ req }, res{ res }, router{ router }, payload{ std::move( payload ) } {}

    ~Stream() = default;

    Stream(const Stream&) = delete;
    Stream& operator=(const Stream&) = delete;
    Stream(Stream&&) = delete;
    Stream& operator=(Stream&&) = delete;

    /**
     * Invoked by a client close event handler.
     * @param state `true` if HTTP client closed connection.
     */
    void close( bool state )
    {
      closed.store( state );
    }

    /**
     * Process a client request.  Route the request to the appropriate handler to generate the response.
     * @param pool The thread pool to delegate processing of any actions in the `extraProcess` function.
     * @param configuration The server configuration.
     */
    void process( boost::asio::thread_pool& pool, const Configuration& configuration )
    {
      using std::operator ""s;
      using std::operator ""sv;
      static const auto methods = std::array{ "DELETE"s, "GET"s, "OPTIONS"s, "PATCH"s, "POST"s, "PUT"s };

      if ( isClosed() )
      {
#ifdef HAS_NANO_LOG
        LOG_INFO << "Client closed connection, not processing " << request.method <<
          " request for " << request.path;
#endif
        return;
      }

      auto rr = RoutingRequest{ .req = request, .configuration = configuration };
      if ( payload ) rr.body = std::string_view{ payload->data(), payload->size() };
      auto response = router.route( request.method, request.path, rr );
      if ( response ) processResponse( pool, std::move( *response ) );
      else
      {
#ifdef HAS_NANO_LOG
        LOG_CRIT << "No response generated by router for " << request.method << " request to " << request.path;
#endif
        processResponse( pool, error<Resp>( 500, methods, request.header, configuration ) );
      }
    }

  private:
    bool isClosed() const { return closed.load(); }

    void processResponse( boost::asio::thread_pool& pool, Resp&& response )
    {
      extraProcess( request, response, pool );
      commit( std::move( response ) );
    }

    void commit( Resp&& response )
    {
      auto self = this->shared_from_this();

      boost::asio::post( res.executor(), [self, resp = std::move( response )]() mutable
      {
        std::lock_guard lg( self->mu );

        if ( self->isClosed() ) return;

        self->res.write_head( resp.status, resp.headers );
        if ( resp.filePath.empty() ) self->res.end( std::move( resp.body ) );
        else self->res.end( nghttp2::asio_http2::file_generator( resp.filePath ) );
      });
    }

    std::mutex mu;
    Request request;
    const nghttp2::asio_http2::server::request& req;
    const nghttp2::asio_http2::server::response& res;
    const Router<Resp>& router;
    std::shared_ptr<std::string> payload{ nullptr };
    std::atomic_bool closed{ false };
  };
}
